
---

### **Single Number Problems**

#### **Easy**
1. **[Single Number](https://leetcode.com/problems/single-number/)**
   - **Problem**: Given a non-empty array of integers, every element appears twice except for one. Find that single one.
   - **Approach**:
     - Brute Force: Use a hash map to count occurrences of each number.
     - Optimized: Use XOR to find the single number.
   - **Time Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(1)\)

   ```python
   def singleNumber(nums):
       result = 0
       for num in nums:
           result ^= num
       return result
   ```

2. **[Single Number II](https://leetcode.com/problems/single-number-ii/)**
   - **Problem**: Given a non-empty array of integers, every element appears three times except for one. Find that single one.
   - **Approach**:
     - Brute Force: Use a hash map to count occurrences of each number.
     - Optimized: Use bit manipulation to count bits and find the single number.
   - **Time Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(1)\)

   ```python
   def singleNumber(nums):
       ones, twos = 0, 0
       for num in nums:
           ones = (ones ^ num) & ~twos
           twos = (twos ^ num) & ~ones
       return ones
   ```

3. **[Single Number III](https://leetcode.com/problems/single-number-iii/)**
   - **Problem**: Given an array of integers, exactly two elements appear once, and all others appear twice. Find the two single numbers.
   - **Approach**:
     - Brute Force: Use a hash map to count occurrences of each number.
     - Optimized: Use XOR to separate the two single numbers.
   - **Time Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(1)\)

   ```python
   def singleNumber(nums):
       xor = 0
       for num in nums:
           xor ^= num
       diff = xor & -xor
       a, b = 0, 0
       for num in nums:
           if num & diff:
               a ^= num
           else:
               b ^= num
       return [a, b]
   ```

---

#### **Medium**
4. **[Missing Number](https://leetcode.com/problems/missing-number/)**
   - **Problem**: Given an array containing `n` distinct numbers taken from `0, 1, 2, ..., n`, find the missing one.
   - **Approach**:
     - Brute Force: Use a hash set to find the missing number.
     - Optimized: Use XOR to find the missing number.
   - **Time Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(1)\)

   ```python
   def missingNumber(nums):
       result = len(nums)
       for i, num in enumerate(nums):
           result ^= i ^ num
       return result
   ```

5. **[Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)**
   - **Problem**: Given an array of integers containing `n + 1` integers where each integer is between `1` and `n` (inclusive), find the duplicate number.
   - **Approach**:
     - Brute Force: Use a hash set to find the duplicate.
     - Optimized: Use Floyd's Tortoise and Hare algorithm.
   - **Time Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(1)\)

   ```python
   def findDuplicate(nums):
       slow, fast = nums[0], nums[0]
       while True:
           slow = nums[slow]
           fast = nums[nums[fast]]
           if slow == fast:
               break
       slow = nums[0]
       while slow != fast:
           slow = nums[slow]
           fast = nums[fast]
       return slow
   ```

6. **[Find the Difference](https://leetcode.com/problems/find-the-difference/)**
   - **Problem**: Given two strings `s` and `t`, where `t` is generated by shuffling `s` and adding one more letter, find the added letter.
   - **Approach**:
     - Brute Force: Use a hash map to count occurrences of each character.
     - Optimized: Use XOR to find the added character.
   - **Time Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(n)\)
     - Optimized: \(O(1)\)

   ```python
   def findTheDifference(s, t):
       result = 0
       for char in s:
           result ^= ord(char)
       for char in t:
           result ^= ord(char)
       return chr(result)
   ```

---

#### **Hard**
7. **[Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)**
   - **Problem**: Given an array of integers, find the maximum XOR of any two numbers.
   - **Approach**:
     - Brute Force: Try all pairs and compute their XOR.
     - Optimized: Use a trie to find the maximum XOR efficiently.
   - **Time Complexity**:
     - Brute Force: \(O(n^2)\)
     - Optimized: \(O(n \cdot \log m)\), where \(m\) is the maximum number.
   - **Space Complexity**:
     - Brute Force: \(O(1)\)
     - Optimized: \(O(n)\)

   ```python
   def findMaximumXOR(nums):
       max_xor = 0
       for i in range(31, -1, -1):
           max_xor <<= 1
           prefixes = {num >> i for num in nums}
           candidate = max_xor | 1
           for p in prefixes:
               if candidate ^ p in prefixes:
                   max_xor = candidate
                   break
       return max_xor
   ```

8. **[Count Triplets That Can Form Two Arrays of Equal XOR](https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)**
   - **Problem**: Given an array of integers, count the number of triplets `(i, j, k)` where `i < j <= k` and the XOR of elements from `i` to `j-1` equals the XOR of elements from `j` to `k`.
   - **Approach**:
     - Brute Force: Try all triplets and compute their XOR.
     - Optimized: Use prefix XOR and hash maps to count valid triplets.
   - **Time Complexity**:
     - Brute Force: \(O(n^3)\)
     - Optimized: \(O(n)\)
   - **Space Complexity**:
     - Brute Force: \(O(1)\)
     - Optimized: \(O(n)\)

   ```python
   def countTriplets(arr):
       prefix = 0
       count = 0
       prefix_counts = {0: 1}
       prefix_sums = {0: 0}
       for i, num in enumerate(arr):
           prefix ^= num
           if prefix in prefix_counts:
               count += prefix_counts[prefix] * i - prefix_sums[prefix]
               prefix_counts[prefix] += 1
               prefix_sums[prefix] += i + 1
           else:
               prefix_counts[prefix] = 1
               prefix_sums[prefix] = i + 1
       return count
   ```

9. **[Minimum Flips to Make a OR b Equal to c](https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/)**
   - **Problem**: Given three integers `a`, `b`, and `c`, return the minimum number of flips to make `a OR b` equal to `c`.
   - **Approach**:
     - Brute Force: Check each bit and count flips.
     - Optimized: Use bitwise operations to count flips efficiently.
   - **Time Complexity**:
     - Brute Force: \(O(\log n)\)
     - Optimized: \(O(\log n)\)
   - **Space Complexity**:
     - Brute Force: \(O(1)\)
     - Optimized: \(O(1)\)

   ```python
   def minFlips(a, b, c):
       flips = 0
       while a > 0 or b > 0 or c > 0:
           bit_a = a & 1
           bit_b = b & 1
           bit_c = c & 1
           if (bit_a | bit_b) != bit_c:
               if bit_c == 1:
                   flips += 1
               else:
                   flips += (bit_a + bit_b)
           a >>= 1
           b >>= 1
           c >>= 1
       return flips
   ```

---

### **Summary of Approaches**
1. **Brute Force**:
   - Use hash maps or nested loops to solve the problem.
   - Time: \(O(n)\) to \(O(n^3)\), Space: \(O(n)\).

2. **Optimized Bit Manipulation**:
   - Use XOR, prefix XOR, or bitwise operations to solve the problem efficiently.
   - Time: \(O(n)\), Space: \(O(1)\).

3. **Trie**:
   - Use a trie to solve problems involving maximum XOR.
   - Time: \(O(n \cdot \log m)\), Space: \(O(n)\).

---

